# -*- coding: utf-8 -*-
"""캡디2 - 10/31코드.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NZ4QDbCylvJ2ujdJL0K5zPse81bDcDzZ

# kcal함수
"""

def kcal(sex,  height, act, purpose):
  '''
  print("- 주의사항 : 성별은 남자면 = 남, 여자는 = 여")
  print("- 주의사항 : 키는 x.xx로 입력해주세요.(예: 175이면 1.75)")

  while 1:
    s, h = input("성별과 키를 입력하세요 : ").split()
    h = float(h)
    if (s == "남" or s == "여") and h < 10:
      break
    else:
      print("잘못 입력했습니다. 다시 입력해주세요.")


  print("\n- 주의사항 : 가벼운 활동 - 25, 일상적 업무 - 30 ~ 35, 심한 활동(육체 노동) - 40")
  while 1:
    act = int(input("활동지수를 25~40으로 입력해주세요 : "))
    if act < 25 or act > 40:
      print("잘못 입력했습니다. 다시 입력해주세요.")
    else:
      break
    '''
    #위에는 개인정보로 성별, 키, 활동량을 받습니다.
####################################################################################################
  '''
  print("\n- 주의사항 : a = 일반인, b = 운동하는 사람, c = 다이어트")
  while 1:
    p = input("목적을 정해주세요 : ")
    if p == "a":
      p_a = [0.4,0.4,0.2]
      break

    elif p == "b":
      p_a = [0.5,0.3,0.2]
      break

    elif p == "c":
      p_a = [0.1,0.1,0.1]
      break

    else :
      print("잘못 입력했습니다. 다시 입력해주세요.")
  '''
  print("\n- 주의사항 : a = 일반인, b = 운동하는 사람, c = 다이어트")
  while 1:
    p = purpose
    if p == "a":
      p_a = [0.4,0.4,0.2]
      break

    elif p == "b":
      p_a = [0.5,0.3,0.2]
      break

    elif p == "c":
      p_a = [0.1,0.1,0.1]
      break

    else :
      print("잘못 입력했습니다. 다시 입력해주세요.")
  #위에는 일반인, 운동인, 다이어터로 선택을 받습니다.
####################################################################################################

  '''
  if s == "남":
    a_weight = h * h * 22

  else :
    a_weight = h * h * 21

  kcal = a_weight * act
  print("\n하루 권장 칼로리 : ", kcal)
  '''
  if sex == "남":
    a_weight = height * height * 22

  else :
    a_weight = height * height * 21

  kcal = a_weight * act
  print("\n하루 권장 칼로리 : ", kcal)


  #위에는 남자의 키*키*22를 하고 활동량을 곱해서 하루 권장 칼로리를 구합니다.
  #위에는 여자의 키*키*21를 하고 활동량을 곱해서 하루 권장 칼로리를 구합니다.
####################################################################################################


  #탄수화물, 단백질, 지방의 권장 섭취량을 주어집니다.
  z_1 = kcal * p_a[0] // 4
  z_2 = kcal * p_a[1] // 4
  z_3 = kcal * p_a[2] // 9
  print("하루 권장 탄수화물 섭취량 : ", z_1)
  print("하루 권장 단백질 섭취량 : ", z_2)
  print("하루 권장 지방 섭취량 : ", z_3)




kcal("남", 1.75, 40, 'b')

"""#kmean 함수"""

def load_kmean(data):
  from sklearn.neighbors import KNeighborsClassifier
  from sklearn.metrics import accuracy_score
  import numpy as np
  import matplotlib.pyplot as plt
  from sklearn.metrics import pairwise_distances_argmin_min
  import pandas as pd

  # 예제 데이터 생성
  # 음식 영양소의 data가 들어감
  #X_train = np.random.rand(100, 3)
  X_train = data

  # 임의의 값 배정
  y_train = np.random.randint(2, size=data.shape[0])

  #X_test = np.array([[1.5, 2.5, 5], [1, 3, 5]])
  #X_test에는 부족한 영양소의 탄,단,지로 3차원 데이터 들어감
  X_test = np.random.rand(1, 3)


  # 다양한 거리 메트릭을 정의합니다.
  distance_metrics = ['euclidean', 'manhattan', 'cosine']

  predictions = []
  i = 0

  # 각 거리 메트릭에 대한 반복
  for metric in distance_metrics:
      knn = KNeighborsClassifier(n_neighbors=5, metric=metric)
      knn.fit(X_train, y_train)



      # k-최근접 이웃의 인덱스를 찾습니다.
      distances, indices = knn.kneighbors(X_test)

      if i == 0 :

        df = pd.DataFrame({ "euclidean" : indices.flatten() })
        i += 1
      elif i == 1:
        df["mahanttan"] = indices.flatten()
        i += 1
      else :
        df["cosine"] = indices.flatten()





      print(f"{metric} 거리를 사용합니다:")
      print(f"가장 가까운 이웃의 인덱스: \n{indices}\n")
      print("가장 가까운 이웃의 index 거리 : \n", distances, '\n')

      y_pred = knn.predict(X_test)

      print(f"X_test에 대한 예측 클래스: {y_pred}")
      print("------------------------------------\n")
      predictions.append(y_pred)

  # 앙상블 방법으로 최종 예측을 수행합니다.
  final_prediction = np.round(np.mean(predictions, axis=0))






  print("Final Prediction:", final_prediction)
  print("\n",df)

  food_1 = []
  for i in range(5):
    for j in range(5):
      if df["euclidean"][i] == df["mahanttan"][j]:
        food_1.append(i)

  food_last = []
  for i in food_1:
    for j in range(5):
      if df["euclidean"][i] == df["cosine"][j] :
        food_last.append(i)

  print("\neuclidean과 mahantan의 교집합 index : ", food_1)
  print("위의 집합에서 cosie 교집합 index :", food_last)
  print("위에 결과는 euclidean_index기준으로 봐주세요")



  # 3D 산점도 그리기
  fig = plt.figure(figsize = (15, 20))
  ax = fig.add_subplot(111, projection='3d')

  # 훈련 데이터 포인트를 그립니다.
  ax.scatter(X_train[y_train == 0][:, 0], X_train[y_train == 0][:, 1], X_train[y_train == 0][:, 2], c='r', marker='o', label='Class 0')
  ax.scatter(X_train[y_train == 1][:, 0], X_train[y_train == 1][:, 1], X_train[y_train == 1][:, 2], c='g', marker='^', label='Class 1')

  # 테스트 데이터 포인트를 그립니다.
  ax.scatter(X_test[:, 0], X_test[:, 1], X_test[:, 2], c='b', marker='x', label='Test Data')

  ax.set_xlabel('Feature 1')
  ax.set_ylabel('Feature 2')
  ax.set_zlabel('Feature 3')

  plt.legend(loc='upper right')
  plt.show()





load_kmean(np.random.rand(100, 3))

"""# 모델을 저장하고 불러오는 코드는 나중에 추가"""

def kmeans(data, test_data):
    from sklearn.neighbors import KNeighborsClassifier
    from sklearn.metrics import accuracy_score
    import numpy as np
    import matplotlib.pyplot as plt
    from sklearn.metrics import pairwise_distances_argmin_min
    import pandas as pd
    import joblib

    # 예제 데이터 생성
    X_train = data
    y_train = np.random.randint(2, size=data.shape[0])
    X_test = test_data

    # 다양한 거리 메트릭을 정의합니다.
    distance_metrics = ['euclidean', 'manhattan', 'cosine']

    # 각 거리 메트릭에 대한 반복
    for metric in distance_metrics:
        knn = KNeighborsClassifier(n_neighbors=5, metric=metric)
        knn.fit(X_train, y_train)

        # k-means 모델 저장
        kmeans_model_filename = f'kmeans_model_{metric}.joblib'
        joblib.dump(knn, kmeans_model_filename)



# 예제 데이터를 생성하고 k-means 모델을 저장하는 코드 실행
data = np.random.rand(100, 3)
X_test = np.random.rand(1, 3)
kmeans(data, X_test)

